@using Blazor.WorkflowEditor.Components
@using System.Activities;
@using System.Xaml;
@using System.Text;
@implements IDisposable


<div class="editor">
    <ModalService @ref="_modalService"></ModalService>
    <CascadingValue Value="_modalService">
        <div class="toolbox" style="@toolboxStyle">
            <div class="caption">
                <div class="row">
                    <div class="col-1">
                        <button type="button" class="btn" @onclick="()=>ToolboxCollapse()">
                            <span class="oi @ToolboxCollapsedIcon() text-primary" aria-hidden="true"></span>
                        </button>
                    </div>
                    @if (!toolboxCollapsed)
                    {

                    <div class="col-11">
                        <div class="input-group">
                            <input type="text" class="form-control" @bind="toolboxFilter">
                            <button type="button" class="btn" @onclick="()=>toolboxFilter=string.Empty">
                                <span class="oi oi-x text-primary" style="align-self: center;"></span>
                            </button>
                        </div>
                    </div>
                }
            </div>
        </div>
        @if (!toolboxCollapsed)
        {
            <ul class="groups list-unstyled">
                @foreach (var group in FilterdToolBoxGroups)
                {
                    <li class="groupItem">
                        <div class="groupName" @onclick="()=>CollapseGroup(group.Name)">
                            <span class="oi @GroupCollapsedIcon(group.Name)" aria-hidden="true"></span>
                            @group.Name
                        </div>
                        <ul class="items list-unstyled @(HasGroupCollapsed(group.Name))">
                            @foreach (var item in group.Items)
                            {
                                <li @key="item" class="@((item.Image==null?"activityItemWithoutIcon":"activityItem"))"
                        draggable="true" @ondragstart="() => OnDragStart(item)"  @ondragenter="() => OnDragEnter(item)">
                                    @if (item.Image != null)
                                    {
                                        <span class="@item.Image" aria-hidden="true"></span>
                                    }
                                    @item.Name
                                </li>
                            }
                        </ul>
                    </li>
                }
            </ul>
        }
    </div>

        <div class="diagram-editor">
            <div class="diagram-path">
                <nav style="--bs-breadcrumb-divider: '>';" aria-label="breadcrumb">
                    <ol class="breadcrumb">
                        @foreach (var pathItem in service.Path)
                        {
                            <li class="breadcrumb-item"><a href="#" @onclick="()=>OpenPath(pathItem)">@pathItem.Name</a>
                            </li>
                        }
                    </ol>
                </nav>
            </div>

        <div class="diagram-main">
            <div class="@diagramStyle" ondragover="event.preventDefault();" @ondragover:preventDefault @ondrop="OnDrop">
                <CascadingValue Value="designer">
                    <CascadingValue Value="service">
                        <DiagramCanvas></DiagramCanvas>
                    </CascadingValue>
                </CascadingValue>
            </div>
        </div>

            <div class="variables">
                <VariablesPanelComponent Service="service" TypeCollection="TypeCollection"></VariablesPanelComponent>
            </div>
        </div>
    </CascadingValue>
</div>

@code {
    private ModalService? _modalService { get; set; }

    private Diagram designer { get; set; } = default!;
    private ToolBoxItem? draggedToolboxItem;
    private Blazor.WorkflowEditor.Service service { get; set; } = default!;

    [Parameter, EditorRequired]
    public IEnumerable<ToolBoxGroup> ToolBoxGroups { get; set; } = default!;

    [Parameter, EditorRequired]
    public List<Type> TypeCollection { get; set; } = default!;

    private IDictionary<string, bool> collapsedGroups = new Dictionary<string, bool>();
    private bool toolboxCollapsed = false;
    private int toolboxWidth = 36;
    private string toolboxStyle = "";

    private string diagramStyle = "diagram";

    private IEnumerable<ToolBoxGroup> FilterdToolBoxGroups
    {
        get
        {
            if (!string.IsNullOrWhiteSpace(toolboxFilter))
            {
                var result = new List<ToolBoxGroup>();
                foreach (var group in ToolBoxGroups)
                {
                    var items = group.Items.Where(s => s.Name.ToLower().Contains(toolboxFilter.ToLower())).ToList();
                    if (items.Count > 0)
                    {
                        result.Add(new ToolBoxGroup
                        {
                            Description = group.Description,
                            Name = group.Name,
                            Items = items
                        });
                    }
                }
                return result;
            }
            return ToolBoxGroups;
        }
    }
    private string toolboxFilter { get; set; } = string.Empty;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        var options = new DiagramOptions
        {
            DeleteKey = "Delete", // What key deletes the selected nodes/links
            DefaultNodeComponent = null, // Default component for nodes
            AllowMultiSelection = true, // Whether to allow multi selection using CTRL
            Links = new DiagramLinkOptions
            {
            },
            Zoom = new DiagramZoomOptions
            {
                Minimum = 0.1, // Minimum zoom value
                Inverse = true, // Whether to inverse the direction of the zoom when using the wheel
            }
        };
        this.designer = new(options);

        this.service = new Service(this.designer, this.StateHasChanged);

        foreach (var item in this.ToolBoxGroups.Where(p => p.Items.Count != 0))
        {
            collapsedGroups.Add(item.Name, false);
        }
    }

    public void Dispose()
    {
        service?.Dispose();
    }

    private void OnDragStart(ToolBoxItem key)
    {
        if (service.CheckAddActivity(key.TypeOfActivity) == false)
            return;

        draggedToolboxItem = key;
    }

    private void OnDragEnter(ToolBoxItem key)
    {
        if (service.CheckAddActivity(key.TypeOfActivity) == false)
            return;
    }

    private async void OnDrop(DragEventArgs e)
    {
        if (draggedToolboxItem == null)
            return;

        if (draggedToolboxItem.TypeOfActivity.IsGenericType)
        {
            var genericTypes = draggedToolboxItem.TypeOfActivity
                .GetGenericArguments()
                .Where(t => t.IsGenericParameter)
                .Select(s => new GenericTypeSelectModal.GenericTypeDescription { Key = s.ToString() })
                .ToList();
            var modal = await   _modalService.ShowModal<GenericTypeSelectModal>(new (){
                {"GenericTypes",genericTypes},
                {"TypeCollection",TypeCollection??new List<Type>()}
            });
            if(modal.ModalResult==ModalResult.Applied){
                (bool hasAdded, var result) =
                service.AddActivity(draggedToolboxItem.TypeOfActivity, modal.BuildedTypes.ToArray()!);
                if (!hasAdded) return;
                var position = designer.GetRelativeMousePoint(e.ClientX, e.ClientY);
                result.Node.CenterPosition = position;
            }
            StateHasChanged();
        }
        else
        {
            (bool hasAdded, var result) = service.AddActivity(draggedToolboxItem.TypeOfActivity);
            if (!hasAdded) return;
            var position = designer.GetRelativeMousePoint(e.ClientX, e.ClientY);
            result.Node.CenterPosition = position;
        }
        draggedToolboxItem = null;
    }

    public void Edit(System.Activities.Activity source)
    {
        var ab = new ActivityBuilder() { Implementation = source };
        service.SetActivityBuilder(ab);
    }

    public void New()
    {
        var ab = new ActivityBuilder() { Implementation = new System.Activities.Statements.Sequence() };
        service.SetActivityBuilder(ab);
    }

    public void Load(string source)
    {
        var xr = new StringReader(source);
        var br = System.Activities.XamlIntegration.ActivityXamlServices.CreateBuilderReader(new XamlXmlReader(xr));
        var ab = XamlServices.Load(br) switch {
            (ActivityBuilder _ab) => _ab,
            (System.Activities.Activity _a) => new ActivityBuilder() { Implementation = _a },
            _ => throw new NotSupportedException()
        };

 
        //TODO add validation info
        //var validationResults = System.Activities.Validation.ActivityValidationServices.Validate(ab.Implementation);

        service.SetActivityBuilder(ab);
    }

    public string Save()
    {
        //var activity = service.GetActivityBuilder();
        //System.Xaml.XamlServices.Save(activity);

        var sb = new StringBuilder();
        var xw = System.Activities.XamlIntegration.ActivityXamlServices.CreateBuilderWriter(new XamlXmlWriter(new StringWriter(sb), new XamlSchemaContext()));
        XamlServices.Save(xw, service.GetActivityBuilder());
        return sb.ToString();
    }

    public void OpenPath(PathItem pathItem)
    {
        service.OpenPath(pathItem);
    }

    private void CollapseGroup(string name)
    {
        if (collapsedGroups.ContainsKey(name))
        {
            collapsedGroups[name] = !collapsedGroups[name];
        }
    }

    private string HasGroupCollapsed(string name)
    {
        if (collapsedGroups.ContainsKey(name))
        {
            return collapsedGroups[name] ? "collapse" : "";
        }
        return string.Empty;
    }

    private string GroupCollapsedIcon(string name)
    {
        if (collapsedGroups.ContainsKey(name))
        {
            return collapsedGroups[name] ? "oi oi-plus" : "oi oi-minus";
        }
        return "";
    }

    private void ToolboxCollapse()
    {
        toolboxCollapsed = !toolboxCollapsed;
        toolboxWidth = toolboxCollapsed ? 36 : 400;
        toolboxStyle = $"width: {toolboxWidth}px;";

    }

    private string ToolboxCollapsedIcon()
    {
        return toolboxCollapsed ? "oi oi-arrow-right" : "oi oi-arrow-left";
    }
}
